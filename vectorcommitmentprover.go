package rsmt2d

import (
	"crypto/sha256"
	"hash"
	"sync"

	"github.com/NebulousLabs/merkletree"
)

// Axis indicates to the prover whether to use columns or rows
type Axis bool

const (
	// Column indicates use of the x axis of a data square
	Column Axis = true
	// Row indicates use of the y axis of a data square
	Row Axis = false
)

// Proof describes the data needed to verify a rsmt2d compatable merkle tree
// notes: I'm not really sure that returning single require struct is more
// convienient than returning four separate objects
type Proof struct {
	Root   []byte
	Set    [][]byte
	Index  uint64
	Leaves uint64
}

// VectorCommitmentProver describes the expected methods for issuing and proving
// vector commitments over portions of a data square
type VectorCommitmentProver interface {
	// Commitment provides the commitment root for the selected row or column.
	// Returns a commitment to a zeroed slice if the index is too high.
	Commitment(a Axis, idx uint) []byte
	// Prove issues a proof that can verify the inclusion of a selected row or column.
	Prove(a Axis, idx uint) (Proof, error)
}

// Commitments uses the provided VectorCommitmentProver to collect commitments
// from a selected axis
func Commitments(a Axis, vcp VectorCommitmentProver, width uint) [][]byte {
	commits := make([][]byte, width)
	for i := uint(0); i < width; i++ {
		commits[i] = vcp.Commitment(a, i)
	}
	return commits
}

// RootHash creates a binary merkle tree root of the commintments generated by
// the provided vcp
// this function should probably be in LL-core
func RootHash(vcp VectorCommitmentProver, width uint) []byte {
	tree := merkletree.New(sha256.New())
	for i := uint(0); i < width; i++ {
		tree.Push(vcp.Commitment(Row, i))
	}
	for i := uint(0); i < width; i++ {
		tree.Push(vcp.Commitment(Column, i))
	}
	return tree.Root()
}

// ParallelRootHash creates a binary merkle tree root of the commitments
// generated by the provided vcp, spinning up 'worker' number of goroutines to
// do so. Assumes that the VectorCommitmentProver provided is thread safe. this
// function should probably be in LL-core
func ParallelRootHash(vcp VectorCommitmentProver, width uint, workers int) []byte {
	var wg sync.WaitGroup
	jobs := make(chan uint, width)
	colRoots := make([][]byte, width)
	rowRoots := make([][]byte, width)
	go func() {
		defer close(jobs)
		for i := uint(0); i < width; i++ {
			jobs <- i
		}
	}()
	work := func(wg *sync.WaitGroup, jobs <-chan uint) {
		defer wg.Done()
		for job := range jobs {
			colRoots[job] = vcp.Commitment(Column, job)
			rowRoots[job] = vcp.Commitment(Row, job)
		}
	}
	for i := 0; i < workers; i++ {
		wg.Add(1)
		work(&wg, jobs)
	}
	wg.Wait()
	tree := merkletree.New(sha256.New())
	for i := uint(0); i < width; i++ {
		tree.Push(rowRoots[i])
	}
	for i := uint(0); i < width; i++ {
		tree.Push(colRoots[i])
	}
	return tree.Root()
}

// defaultVCP uses NebulousLabs' merkle tree implementation to fullfill the
// VectorCommitmentProver interface.
type defaultVCP struct {
	eds    *ExtendedDataSquare
	hasher func() hash.Hash
}

func newDefaultVCP(eds *ExtendedDataSquare) VectorCommitmentProver {
	return defaultVCP{
		eds:    eds,
		hasher: sha256.New,
	}
}

// Commitment fullfills the VectorCommitmentProver interface by using
// NebulousLabs' merkle tree implementation to generation a merkle root for the
// selected row or column
func (d defaultVCP) Commitment(a Axis, idx uint) []byte {
	leaves := d.fetchLeaves(a, idx)
	tree := merkletree.New(d.hasher())
	err := tree.SetIndex(uint64(idx))
	// we should never have to worry about this considering we're making an empty tree
	if err != nil {
		panic(err)
	}
	for _, leaf := range leaves {
		tree.Push(leaf)
	}
	return tree.Root()
}

// Prove fullfills the VectorCommitmentProver interface by using
// NebulousLabs' merkle tree implementation to generate a merkle proof for the
// selected row or column
func (d defaultVCP) Prove(a Axis, idx uint) (proof Proof, err error) {
	leaves := d.fetchLeaves(a, idx)
	tree := merkletree.New(d.hasher())
	err = tree.SetIndex(uint64(idx))
	if err != nil {
		return proof, err
	}
	for _, leaf := range leaves {
		tree.Push(leaf)
	}
	merkleRoot, proofSet, proofIndex, numLeaves := tree.Prove()
	return Proof{
		Root:   merkleRoot,
		Set:    proofSet,
		Index:  proofIndex,
		Leaves: numLeaves,
	}, nil
}

// fetchLeaves gets the column or row data from the underlying data
// square
func (d defaultVCP) fetchLeaves(a Axis, idx uint) [][]byte {
	// todo(evan): change to better optimize for data rectangles
	leaves := make([][]byte, d.eds.width)
	switch a {
	case Column:
		leaves = d.eds.Column(idx)
	case Row:
		leaves = d.eds.Row(idx)
	}
	return leaves
}
